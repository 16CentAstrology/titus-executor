// Code generated by protoc-gen-go. DO NOT EDIT.
// source: vpc.proto

package vpcapi

import (
	context "context"
	fmt "fmt"
	math "math"

	titus "github.com/Netflix/titus-executor/api/netflix/titus"
	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// This is embedded in responses / replies so that a given IP Service Server may cache data from AWS. Since the client
// is the only one ever going to make requests for that given ENI, it can take a lock on that ENI. If the cache version
// the client presents is not present, or it is different from the one the server has, the server must refresh its
// state from AWS
type CacheVersion struct {
	Uuid                 []byte   `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CacheVersion) Reset()         { *m = CacheVersion{} }
func (m *CacheVersion) String() string { return proto.CompactTextString(m) }
func (*CacheVersion) ProtoMessage()    {}
func (*CacheVersion) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{0}
}

func (m *CacheVersion) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CacheVersion.Unmarshal(m, b)
}
func (m *CacheVersion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CacheVersion.Marshal(b, m, deterministic)
}
func (m *CacheVersion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CacheVersion.Merge(m, src)
}
func (m *CacheVersion) XXX_Size() int {
	return xxx_messageInfo_CacheVersion.Size(m)
}
func (m *CacheVersion) XXX_DiscardUnknown() {
	xxx_messageInfo_CacheVersion.DiscardUnknown(m)
}

var xxx_messageInfo_CacheVersion proto.InternalMessageInfo

func (m *CacheVersion) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

type NetworkInterfaceAttachment struct {
	// 0-indexed
	DeviceIndex          uint32   `protobuf:"varint,1,opt,name=deviceIndex,proto3" json:"deviceIndex,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NetworkInterfaceAttachment) Reset()         { *m = NetworkInterfaceAttachment{} }
func (m *NetworkInterfaceAttachment) String() string { return proto.CompactTextString(m) }
func (*NetworkInterfaceAttachment) ProtoMessage()    {}
func (*NetworkInterfaceAttachment) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{1}
}

func (m *NetworkInterfaceAttachment) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkInterfaceAttachment.Unmarshal(m, b)
}
func (m *NetworkInterfaceAttachment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkInterfaceAttachment.Marshal(b, m, deterministic)
}
func (m *NetworkInterfaceAttachment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkInterfaceAttachment.Merge(m, src)
}
func (m *NetworkInterfaceAttachment) XXX_Size() int {
	return xxx_messageInfo_NetworkInterfaceAttachment.Size(m)
}
func (m *NetworkInterfaceAttachment) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkInterfaceAttachment.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkInterfaceAttachment proto.InternalMessageInfo

func (m *NetworkInterfaceAttachment) GetDeviceIndex() uint32 {
	if m != nil {
		return m.DeviceIndex
	}
	return 0
}

type NetworkInterface struct {
	SubnetId                   string                      `protobuf:"bytes,1,opt,name=subnetId,proto3" json:"subnetId,omitempty"`
	AvailabilityZone           string                      `protobuf:"bytes,2,opt,name=availabilityZone,proto3" json:"availabilityZone,omitempty"`
	MacAddress                 string                      `protobuf:"bytes,3,opt,name=macAddress,proto3" json:"macAddress,omitempty"`
	NetworkInterfaceId         string                      `protobuf:"bytes,4,opt,name=networkInterfaceId,proto3" json:"networkInterfaceId,omitempty"`
	OwnerAccountId             string                      `protobuf:"bytes,5,opt,name=ownerAccountId,proto3" json:"ownerAccountId,omitempty"`
	AttachedInstanceID         string                      `protobuf:"bytes,6,opt,name=attachedInstanceID,proto3" json:"attachedInstanceID,omitempty"`
	NetworkInterfaceAttachment *NetworkInterfaceAttachment `protobuf:"bytes,7,opt,name=networkInterfaceAttachment,proto3" json:"networkInterfaceAttachment,omitempty"`
	VpcId                      string                      `protobuf:"bytes,8,opt,name=vpcId,proto3" json:"vpcId,omitempty"`
	XXX_NoUnkeyedLiteral       struct{}                    `json:"-"`
	XXX_unrecognized           []byte                      `json:"-"`
	XXX_sizecache              int32                       `json:"-"`
}

func (m *NetworkInterface) Reset()         { *m = NetworkInterface{} }
func (m *NetworkInterface) String() string { return proto.CompactTextString(m) }
func (*NetworkInterface) ProtoMessage()    {}
func (*NetworkInterface) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{2}
}

func (m *NetworkInterface) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NetworkInterface.Unmarshal(m, b)
}
func (m *NetworkInterface) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NetworkInterface.Marshal(b, m, deterministic)
}
func (m *NetworkInterface) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkInterface.Merge(m, src)
}
func (m *NetworkInterface) XXX_Size() int {
	return xxx_messageInfo_NetworkInterface.Size(m)
}
func (m *NetworkInterface) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkInterface.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkInterface proto.InternalMessageInfo

func (m *NetworkInterface) GetSubnetId() string {
	if m != nil {
		return m.SubnetId
	}
	return ""
}

func (m *NetworkInterface) GetAvailabilityZone() string {
	if m != nil {
		return m.AvailabilityZone
	}
	return ""
}

func (m *NetworkInterface) GetMacAddress() string {
	if m != nil {
		return m.MacAddress
	}
	return ""
}

func (m *NetworkInterface) GetNetworkInterfaceId() string {
	if m != nil {
		return m.NetworkInterfaceId
	}
	return ""
}

func (m *NetworkInterface) GetOwnerAccountId() string {
	if m != nil {
		return m.OwnerAccountId
	}
	return ""
}

func (m *NetworkInterface) GetAttachedInstanceID() string {
	if m != nil {
		return m.AttachedInstanceID
	}
	return ""
}

func (m *NetworkInterface) GetNetworkInterfaceAttachment() *NetworkInterfaceAttachment {
	if m != nil {
		return m.NetworkInterfaceAttachment
	}
	return nil
}

func (m *NetworkInterface) GetVpcId() string {
	if m != nil {
		return m.VpcId
	}
	return ""
}

type InstanceIdentity struct {
	// This is duplicated data , but we include it for verification beyond Metatron. No containers should run
	// on the instance prior to this API call being completed. We can then rely on the instance
	// identity document for further verification.
	InstanceIdentityDocument  []byte   `protobuf:"bytes,1,opt,name=instanceIdentityDocument,proto3" json:"instanceIdentityDocument,omitempty"`
	InstanceIdentitySignature []byte   `protobuf:"bytes,2,opt,name=instanceIdentitySignature,proto3" json:"instanceIdentitySignature,omitempty"`
	InstanceID                string   `protobuf:"bytes,3,opt,name=instanceID,proto3" json:"instanceID,omitempty"`
	Region                    string   `protobuf:"bytes,4,opt,name=region,proto3" json:"region,omitempty"`
	AccountID                 string   `protobuf:"bytes,5,opt,name=accountID,proto3" json:"accountID,omitempty"`
	InstanceType              string   `protobuf:"bytes,6,opt,name=instanceType,proto3" json:"instanceType,omitempty"`
	XXX_NoUnkeyedLiteral      struct{} `json:"-"`
	XXX_unrecognized          []byte   `json:"-"`
	XXX_sizecache             int32    `json:"-"`
}

func (m *InstanceIdentity) Reset()         { *m = InstanceIdentity{} }
func (m *InstanceIdentity) String() string { return proto.CompactTextString(m) }
func (*InstanceIdentity) ProtoMessage()    {}
func (*InstanceIdentity) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{3}
}

func (m *InstanceIdentity) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InstanceIdentity.Unmarshal(m, b)
}
func (m *InstanceIdentity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InstanceIdentity.Marshal(b, m, deterministic)
}
func (m *InstanceIdentity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceIdentity.Merge(m, src)
}
func (m *InstanceIdentity) XXX_Size() int {
	return xxx_messageInfo_InstanceIdentity.Size(m)
}
func (m *InstanceIdentity) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceIdentity.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceIdentity proto.InternalMessageInfo

func (m *InstanceIdentity) GetInstanceIdentityDocument() []byte {
	if m != nil {
		return m.InstanceIdentityDocument
	}
	return nil
}

func (m *InstanceIdentity) GetInstanceIdentitySignature() []byte {
	if m != nil {
		return m.InstanceIdentitySignature
	}
	return nil
}

func (m *InstanceIdentity) GetInstanceID() string {
	if m != nil {
		return m.InstanceID
	}
	return ""
}

func (m *InstanceIdentity) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *InstanceIdentity) GetAccountID() string {
	if m != nil {
		return m.AccountID
	}
	return ""
}

func (m *InstanceIdentity) GetInstanceType() string {
	if m != nil {
		return m.InstanceType
	}
	return ""
}

// ProvisionInstanceRequest is called when the instance is first initialized, in order to configure its interfaces,
// and other network capabilities.
// The provisioning service decides which account / subnet / VPC the interface will live in.
type ProvisionInstanceRequest struct {
	// We don't include the subnet ID here because the instance subnets should be decided on the side of the IP Service
	InstanceIdentity     *InstanceIdentity `protobuf:"bytes,1,opt,name=instanceIdentity,proto3" json:"instanceIdentity,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ProvisionInstanceRequest) Reset()         { *m = ProvisionInstanceRequest{} }
func (m *ProvisionInstanceRequest) String() string { return proto.CompactTextString(m) }
func (*ProvisionInstanceRequest) ProtoMessage()    {}
func (*ProvisionInstanceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{4}
}

func (m *ProvisionInstanceRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ProvisionInstanceRequest.Unmarshal(m, b)
}
func (m *ProvisionInstanceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ProvisionInstanceRequest.Marshal(b, m, deterministic)
}
func (m *ProvisionInstanceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionInstanceRequest.Merge(m, src)
}
func (m *ProvisionInstanceRequest) XXX_Size() int {
	return xxx_messageInfo_ProvisionInstanceRequest.Size(m)
}
func (m *ProvisionInstanceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionInstanceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionInstanceRequest proto.InternalMessageInfo

func (m *ProvisionInstanceRequest) GetInstanceIdentity() *InstanceIdentity {
	if m != nil {
		return m.InstanceIdentity
	}
	return nil
}

type ProvisionInstanceResponse struct {
	// In this, the deviceIndex, macAddress, and networkInterfaceId must be unique in this list.
	NetworkInterfaces    []*NetworkInterface `protobuf:"bytes,1,rep,name=networkInterfaces,proto3" json:"networkInterfaces,omitempty"`
	CacheVersion         *CacheVersion       `protobuf:"bytes,2,opt,name=cacheVersion,proto3" json:"cacheVersion,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ProvisionInstanceResponse) Reset()         { *m = ProvisionInstanceResponse{} }
func (m *ProvisionInstanceResponse) String() string { return proto.CompactTextString(m) }
func (*ProvisionInstanceResponse) ProtoMessage()    {}
func (*ProvisionInstanceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{5}
}

func (m *ProvisionInstanceResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ProvisionInstanceResponse.Unmarshal(m, b)
}
func (m *ProvisionInstanceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ProvisionInstanceResponse.Marshal(b, m, deterministic)
}
func (m *ProvisionInstanceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionInstanceResponse.Merge(m, src)
}
func (m *ProvisionInstanceResponse) XXX_Size() int {
	return xxx_messageInfo_ProvisionInstanceResponse.Size(m)
}
func (m *ProvisionInstanceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionInstanceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionInstanceResponse proto.InternalMessageInfo

func (m *ProvisionInstanceResponse) GetNetworkInterfaces() []*NetworkInterface {
	if m != nil {
		return m.NetworkInterfaces
	}
	return nil
}

func (m *ProvisionInstanceResponse) GetCacheVersion() *CacheVersion {
	if m != nil {
		return m.CacheVersion
	}
	return nil
}

type UtilizedAddress struct {
	Address              *titus.Address       `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	LastUsedTime         *timestamp.Timestamp `protobuf:"bytes,2,opt,name=lastUsedTime,proto3" json:"lastUsedTime,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *UtilizedAddress) Reset()         { *m = UtilizedAddress{} }
func (m *UtilizedAddress) String() string { return proto.CompactTextString(m) }
func (*UtilizedAddress) ProtoMessage()    {}
func (*UtilizedAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{6}
}

func (m *UtilizedAddress) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UtilizedAddress.Unmarshal(m, b)
}
func (m *UtilizedAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UtilizedAddress.Marshal(b, m, deterministic)
}
func (m *UtilizedAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UtilizedAddress.Merge(m, src)
}
func (m *UtilizedAddress) XXX_Size() int {
	return xxx_messageInfo_UtilizedAddress.Size(m)
}
func (m *UtilizedAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_UtilizedAddress.DiscardUnknown(m)
}

var xxx_messageInfo_UtilizedAddress proto.InternalMessageInfo

func (m *UtilizedAddress) GetAddress() *titus.Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *UtilizedAddress) GetLastUsedTime() *timestamp.Timestamp {
	if m != nil {
		return m.LastUsedTime
	}
	return nil
}

type AssignIPRequest struct {
	CacheVersion *CacheVersion `protobuf:"bytes,1,opt,name=cacheVersion,proto3" json:"cacheVersion,omitempty"`
	// This is optional. If it is not specified then we will assign a "random" IP to the interface
	SignedAddressAllocation    *titus.SignedAddressAllocation `protobuf:"bytes,2,opt,name=signedAddressAllocation,proto3" json:"signedAddressAllocation,omitempty"`
	NetworkInterfaceAttachment *NetworkInterfaceAttachment    `protobuf:"bytes,3,opt,name=networkInterfaceAttachment,proto3" json:"networkInterfaceAttachment,omitempty"`
	SecurityGroupIds           []string                       `protobuf:"bytes,4,rep,name=securityGroupIds,proto3" json:"securityGroupIds,omitempty"`
	RequestedAddresses         []*titus.Address               `protobuf:"bytes,5,rep,name=requestedAddresses,proto3" json:"requestedAddresses,omitempty"`
	UtilizedAddresses          []*UtilizedAddress             `protobuf:"bytes,6,rep,name=utilizedAddresses,proto3" json:"utilizedAddresses,omitempty"`
	InstanceIdentity           *InstanceIdentity              `protobuf:"bytes,7,opt,name=instanceIdentity,proto3" json:"instanceIdentity,omitempty"`
	AllowSecurityGroupChange   bool                           `protobuf:"varint,8,opt,name=allowSecurityGroupChange,proto3" json:"allowSecurityGroupChange,omitempty"`
	XXX_NoUnkeyedLiteral       struct{}                       `json:"-"`
	XXX_unrecognized           []byte                         `json:"-"`
	XXX_sizecache              int32                          `json:"-"`
}

func (m *AssignIPRequest) Reset()         { *m = AssignIPRequest{} }
func (m *AssignIPRequest) String() string { return proto.CompactTextString(m) }
func (*AssignIPRequest) ProtoMessage()    {}
func (*AssignIPRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{7}
}

func (m *AssignIPRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AssignIPRequest.Unmarshal(m, b)
}
func (m *AssignIPRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AssignIPRequest.Marshal(b, m, deterministic)
}
func (m *AssignIPRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssignIPRequest.Merge(m, src)
}
func (m *AssignIPRequest) XXX_Size() int {
	return xxx_messageInfo_AssignIPRequest.Size(m)
}
func (m *AssignIPRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AssignIPRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AssignIPRequest proto.InternalMessageInfo

func (m *AssignIPRequest) GetCacheVersion() *CacheVersion {
	if m != nil {
		return m.CacheVersion
	}
	return nil
}

func (m *AssignIPRequest) GetSignedAddressAllocation() *titus.SignedAddressAllocation {
	if m != nil {
		return m.SignedAddressAllocation
	}
	return nil
}

func (m *AssignIPRequest) GetNetworkInterfaceAttachment() *NetworkInterfaceAttachment {
	if m != nil {
		return m.NetworkInterfaceAttachment
	}
	return nil
}

func (m *AssignIPRequest) GetSecurityGroupIds() []string {
	if m != nil {
		return m.SecurityGroupIds
	}
	return nil
}

func (m *AssignIPRequest) GetRequestedAddresses() []*titus.Address {
	if m != nil {
		return m.RequestedAddresses
	}
	return nil
}

func (m *AssignIPRequest) GetUtilizedAddresses() []*UtilizedAddress {
	if m != nil {
		return m.UtilizedAddresses
	}
	return nil
}

func (m *AssignIPRequest) GetInstanceIdentity() *InstanceIdentity {
	if m != nil {
		return m.InstanceIdentity
	}
	return nil
}

func (m *AssignIPRequest) GetAllowSecurityGroupChange() bool {
	if m != nil {
		return m.AllowSecurityGroupChange
	}
	return false
}

type AssignIPResponse struct {
	CacheVersion *CacheVersion `protobuf:"bytes,1,opt,name=cacheVersion,proto3" json:"cacheVersion,omitempty"`
	// A batch of IPs may be given back. It is up to the client to figure out what IPs it can use.
	UsableAddresses      []*UsableAddress  `protobuf:"bytes,2,rep,name=usableAddresses,proto3" json:"usableAddresses,omitempty"`
	NetworkInterface     *NetworkInterface `protobuf:"bytes,3,opt,name=networkInterface,proto3" json:"networkInterface,omitempty"`
	SecurityGroupIds     []string          `protobuf:"bytes,4,rep,name=securityGroupIds,proto3" json:"securityGroupIds,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *AssignIPResponse) Reset()         { *m = AssignIPResponse{} }
func (m *AssignIPResponse) String() string { return proto.CompactTextString(m) }
func (*AssignIPResponse) ProtoMessage()    {}
func (*AssignIPResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{8}
}

func (m *AssignIPResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AssignIPResponse.Unmarshal(m, b)
}
func (m *AssignIPResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AssignIPResponse.Marshal(b, m, deterministic)
}
func (m *AssignIPResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssignIPResponse.Merge(m, src)
}
func (m *AssignIPResponse) XXX_Size() int {
	return xxx_messageInfo_AssignIPResponse.Size(m)
}
func (m *AssignIPResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AssignIPResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AssignIPResponse proto.InternalMessageInfo

func (m *AssignIPResponse) GetCacheVersion() *CacheVersion {
	if m != nil {
		return m.CacheVersion
	}
	return nil
}

func (m *AssignIPResponse) GetUsableAddresses() []*UsableAddress {
	if m != nil {
		return m.UsableAddresses
	}
	return nil
}

func (m *AssignIPResponse) GetNetworkInterface() *NetworkInterface {
	if m != nil {
		return m.NetworkInterface
	}
	return nil
}

func (m *AssignIPResponse) GetSecurityGroupIds() []string {
	if m != nil {
		return m.SecurityGroupIds
	}
	return nil
}

type UsableAddress struct {
	Address              *titus.Address `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Resolver             *titus.Address `protobuf:"bytes,2,opt,name=resolver,proto3" json:"resolver,omitempty"`
	Gateway              *titus.Address `protobuf:"bytes,3,opt,name=gateway,proto3" json:"gateway,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *UsableAddress) Reset()         { *m = UsableAddress{} }
func (m *UsableAddress) String() string { return proto.CompactTextString(m) }
func (*UsableAddress) ProtoMessage()    {}
func (*UsableAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{9}
}

func (m *UsableAddress) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UsableAddress.Unmarshal(m, b)
}
func (m *UsableAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UsableAddress.Marshal(b, m, deterministic)
}
func (m *UsableAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsableAddress.Merge(m, src)
}
func (m *UsableAddress) XXX_Size() int {
	return xxx_messageInfo_UsableAddress.Size(m)
}
func (m *UsableAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_UsableAddress.DiscardUnknown(m)
}

var xxx_messageInfo_UsableAddress proto.InternalMessageInfo

func (m *UsableAddress) GetAddress() *titus.Address {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *UsableAddress) GetResolver() *titus.Address {
	if m != nil {
		return m.Resolver
	}
	return nil
}

func (m *UsableAddress) GetGateway() *titus.Address {
	if m != nil {
		return m.Gateway
	}
	return nil
}

// AddressGCMetadata is sent when the instance requests that the IP Service GC it. It's basically a way to
// indicate when the IP was last used, and we can GC it based on that metadata.
type GCRequest struct {
	CacheVersion               *CacheVersion               `protobuf:"bytes,1,opt,name=cacheVersion,proto3" json:"cacheVersion,omitempty"`
	NetworkInterfaceAttachment *NetworkInterfaceAttachment `protobuf:"bytes,2,opt,name=networkInterfaceAttachment,proto3" json:"networkInterfaceAttachment,omitempty"`
	UnallocatedAddresses       []*UtilizedAddress          `protobuf:"bytes,3,rep,name=unallocatedAddresses,proto3" json:"unallocatedAddresses,omitempty"`
	NonviableAddresses         []*UtilizedAddress          `protobuf:"bytes,4,rep,name=nonviableAddresses,proto3" json:"nonviableAddresses,omitempty"`
	AllocatedAddresses         []*UtilizedAddress          `protobuf:"bytes,5,rep,name=allocatedAddresses,proto3" json:"allocatedAddresses,omitempty"`
	XXX_NoUnkeyedLiteral       struct{}                    `json:"-"`
	XXX_unrecognized           []byte                      `json:"-"`
	XXX_sizecache              int32                       `json:"-"`
}

func (m *GCRequest) Reset()         { *m = GCRequest{} }
func (m *GCRequest) String() string { return proto.CompactTextString(m) }
func (*GCRequest) ProtoMessage()    {}
func (*GCRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{10}
}

func (m *GCRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GCRequest.Unmarshal(m, b)
}
func (m *GCRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GCRequest.Marshal(b, m, deterministic)
}
func (m *GCRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCRequest.Merge(m, src)
}
func (m *GCRequest) XXX_Size() int {
	return xxx_messageInfo_GCRequest.Size(m)
}
func (m *GCRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GCRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GCRequest proto.InternalMessageInfo

func (m *GCRequest) GetCacheVersion() *CacheVersion {
	if m != nil {
		return m.CacheVersion
	}
	return nil
}

func (m *GCRequest) GetNetworkInterfaceAttachment() *NetworkInterfaceAttachment {
	if m != nil {
		return m.NetworkInterfaceAttachment
	}
	return nil
}

func (m *GCRequest) GetUnallocatedAddresses() []*UtilizedAddress {
	if m != nil {
		return m.UnallocatedAddresses
	}
	return nil
}

func (m *GCRequest) GetNonviableAddresses() []*UtilizedAddress {
	if m != nil {
		return m.NonviableAddresses
	}
	return nil
}

func (m *GCRequest) GetAllocatedAddresses() []*UtilizedAddress {
	if m != nil {
		return m.AllocatedAddresses
	}
	return nil
}

type GCResponse struct {
	CacheVersion         *CacheVersion    `protobuf:"bytes,1,opt,name=cacheVersion,proto3" json:"cacheVersion,omitempty"`
	AddressToBump        []*titus.Address `protobuf:"bytes,2,rep,name=addressToBump,proto3" json:"addressToBump,omitempty"`
	AddressToDelete      []*titus.Address `protobuf:"bytes,3,rep,name=addressToDelete,proto3" json:"addressToDelete,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *GCResponse) Reset()         { *m = GCResponse{} }
func (m *GCResponse) String() string { return proto.CompactTextString(m) }
func (*GCResponse) ProtoMessage()    {}
func (*GCResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_95d23e4d548ba1d7, []int{11}
}

func (m *GCResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GCResponse.Unmarshal(m, b)
}
func (m *GCResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GCResponse.Marshal(b, m, deterministic)
}
func (m *GCResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GCResponse.Merge(m, src)
}
func (m *GCResponse) XXX_Size() int {
	return xxx_messageInfo_GCResponse.Size(m)
}
func (m *GCResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GCResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GCResponse proto.InternalMessageInfo

func (m *GCResponse) GetCacheVersion() *CacheVersion {
	if m != nil {
		return m.CacheVersion
	}
	return nil
}

func (m *GCResponse) GetAddressToBump() []*titus.Address {
	if m != nil {
		return m.AddressToBump
	}
	return nil
}

func (m *GCResponse) GetAddressToDelete() []*titus.Address {
	if m != nil {
		return m.AddressToDelete
	}
	return nil
}

func init() {
	proto.RegisterType((*CacheVersion)(nil), "com.netflix.titus.executor.vpc.CacheVersion")
	proto.RegisterType((*NetworkInterfaceAttachment)(nil), "com.netflix.titus.executor.vpc.NetworkInterfaceAttachment")
	proto.RegisterType((*NetworkInterface)(nil), "com.netflix.titus.executor.vpc.NetworkInterface")
	proto.RegisterType((*InstanceIdentity)(nil), "com.netflix.titus.executor.vpc.InstanceIdentity")
	proto.RegisterType((*ProvisionInstanceRequest)(nil), "com.netflix.titus.executor.vpc.ProvisionInstanceRequest")
	proto.RegisterType((*ProvisionInstanceResponse)(nil), "com.netflix.titus.executor.vpc.ProvisionInstanceResponse")
	proto.RegisterType((*UtilizedAddress)(nil), "com.netflix.titus.executor.vpc.UtilizedAddress")
	proto.RegisterType((*AssignIPRequest)(nil), "com.netflix.titus.executor.vpc.AssignIPRequest")
	proto.RegisterType((*AssignIPResponse)(nil), "com.netflix.titus.executor.vpc.AssignIPResponse")
	proto.RegisterType((*UsableAddress)(nil), "com.netflix.titus.executor.vpc.UsableAddress")
	proto.RegisterType((*GCRequest)(nil), "com.netflix.titus.executor.vpc.GCRequest")
	proto.RegisterType((*GCResponse)(nil), "com.netflix.titus.executor.vpc.GCResponse")
}

func init() { proto.RegisterFile("vpc.proto", fileDescriptor_95d23e4d548ba1d7) }

var fileDescriptor_95d23e4d548ba1d7 = []byte{
	// 1000 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0x5d, 0x6f, 0xe3, 0x44,
	0x17, 0x96, 0x93, 0x7e, 0xa4, 0xa7, 0xe9, 0xdb, 0x74, 0x54, 0xbd, 0x78, 0x2d, 0xb4, 0x14, 0x5f,
	0xa0, 0xa5, 0x02, 0x77, 0x55, 0x10, 0x82, 0x15, 0x5a, 0x91, 0x4d, 0xa4, 0x2a, 0x5c, 0xa0, 0xca,
	0xcd, 0x2e, 0xd2, 0xf2, 0x51, 0x4d, 0xc6, 0xa7, 0xe9, 0x08, 0x67, 0xc6, 0x78, 0xc6, 0x6e, 0xb3,
	0x57, 0x5c, 0x01, 0x3f, 0x80, 0x7f, 0x82, 0xc4, 0x5f, 0xe0, 0x8a, 0xbf, 0xc1, 0x1d, 0xff, 0x01,
	0xf9, 0x23, 0x5f, 0x8e, 0x93, 0x74, 0xc3, 0xf6, 0xa6, 0xaa, 0x8f, 0xcf, 0x79, 0xce, 0xcc, 0xf3,
	0x9c, 0xf3, 0xc8, 0x81, 0x9d, 0x38, 0x60, 0x4e, 0x10, 0x4a, 0x2d, 0xc9, 0x43, 0x26, 0x07, 0x8e,
	0x40, 0x7d, 0xe5, 0xf3, 0x5b, 0x47, 0x73, 0x1d, 0x29, 0x07, 0x6f, 0x91, 0x45, 0x5a, 0x86, 0x4e,
	0x1c, 0x30, 0xeb, 0x9d, 0xbe, 0x94, 0x7d, 0x1f, 0x4f, 0xd2, 0xec, 0x5e, 0x74, 0x75, 0xa2, 0xf9,
	0x00, 0x95, 0xa6, 0x83, 0x20, 0x03, 0xb0, 0xde, 0xcd, 0x8b, 0x4f, 0xd2, 0xe2, 0xec, 0xef, 0x65,
	0x1c, 0xb0, 0x4b, 0x1a, 0xf0, 0x2c, 0xc5, 0xb6, 0xa1, 0xde, 0xa2, 0xec, 0x1a, 0x5f, 0x60, 0xa8,
	0xb8, 0x14, 0x84, 0xc0, 0x46, 0x14, 0x71, 0xcf, 0x34, 0x8e, 0x8c, 0x47, 0x75, 0x37, 0xfd, 0xdf,
	0x7e, 0x0a, 0xd6, 0x57, 0xa8, 0x6f, 0x64, 0xf8, 0x43, 0x47, 0x68, 0x0c, 0xaf, 0x28, 0xc3, 0xa6,
	0xd6, 0x94, 0x5d, 0x0f, 0x50, 0x68, 0x72, 0x04, 0xbb, 0x1e, 0xc6, 0x9c, 0x61, 0x47, 0x78, 0x78,
	0x9b, 0x16, 0xee, 0xb9, 0xd3, 0x21, 0xfb, 0xb7, 0x2a, 0x34, 0x8a, 0x00, 0xc4, 0x82, 0x9a, 0x8a,
	0x7a, 0x02, 0x75, 0x27, 0x6b, 0xb6, 0xe3, 0x8e, 0x9f, 0xc9, 0x31, 0x34, 0x68, 0x4c, 0xb9, 0x4f,
	0x7b, 0xdc, 0xe7, 0x7a, 0xf8, 0x52, 0x0a, 0x34, 0x2b, 0x69, 0xce, 0x5c, 0x9c, 0x3c, 0x04, 0x18,
	0x50, 0xd6, 0xf4, 0xbc, 0x10, 0x95, 0x32, 0xab, 0x69, 0xd6, 0x54, 0x84, 0x38, 0x40, 0x44, 0xa1,
	0x77, 0xc7, 0x33, 0x37, 0xd2, 0xbc, 0x92, 0x37, 0xe4, 0x3d, 0xf8, 0x9f, 0xbc, 0x11, 0x18, 0x36,
	0x19, 0x93, 0x91, 0x48, 0x4e, 0xb7, 0x99, 0xe6, 0x16, 0xa2, 0x09, 0x2e, 0x4d, 0x49, 0x40, 0xaf,
	0x23, 0x94, 0xa6, 0x82, 0x61, 0xa7, 0x6d, 0x6e, 0x65, 0xb8, 0xf3, 0x6f, 0xc8, 0x2b, 0xb0, 0xc4,
	0x42, 0x12, 0xcd, 0xed, 0x23, 0xe3, 0xd1, 0xee, 0xe9, 0x13, 0x67, 0xb9, 0xe2, 0xce, 0x62, 0x19,
	0xdc, 0x25, 0xe8, 0xe4, 0x10, 0x36, 0xe3, 0x80, 0x75, 0x3c, 0xb3, 0x96, 0x1e, 0x2f, 0x7b, 0xb0,
	0x7f, 0xae, 0x40, 0x63, 0x7c, 0x40, 0x0f, 0x85, 0xe6, 0x7a, 0x48, 0x9e, 0x80, 0xc9, 0x0b, 0xb1,
	0xb6, 0x64, 0x51, 0x7a, 0xc8, 0x6c, 0x26, 0x16, 0xbe, 0x27, 0x9f, 0xc3, 0x83, 0xe2, 0xbb, 0x0b,
	0xde, 0x17, 0x54, 0x47, 0x61, 0xa6, 0x5f, 0xdd, 0x5d, 0x9c, 0x90, 0x08, 0xc9, 0x27, 0x44, 0xe6,
	0x42, 0x4e, 0x22, 0xe4, 0xff, 0xb0, 0x15, 0x62, 0x9f, 0x4b, 0x91, 0x8b, 0x97, 0x3f, 0x91, 0xb7,
	0x61, 0x87, 0xe6, 0xaa, 0xb4, 0x73, 0xad, 0x26, 0x01, 0x62, 0x43, 0x7d, 0x84, 0xd1, 0x1d, 0x06,
	0x98, 0x0b, 0x34, 0x13, 0xb3, 0x6f, 0xc1, 0x3c, 0x0f, 0x65, 0xcc, 0x93, 0x05, 0x18, 0x11, 0xe2,
	0xe2, 0x8f, 0x11, 0x2a, 0x4d, 0xbe, 0x85, 0x46, 0xf1, 0xc8, 0x29, 0x0f, 0xbb, 0xa7, 0x8f, 0x57,
	0x89, 0x55, 0xe4, 0xd6, 0x9d, 0x43, 0xb2, 0xff, 0x32, 0xe0, 0x41, 0x49, 0x6b, 0x15, 0x48, 0xa1,
	0x90, 0x7c, 0x0f, 0x07, 0x45, 0x51, 0x95, 0x69, 0x1c, 0x55, 0xef, 0xd2, 0xbc, 0x38, 0x29, 0xee,
	0x3c, 0x14, 0x39, 0x87, 0x3a, 0x9b, 0xda, 0xfd, 0x54, 0xa2, 0xdd, 0xd3, 0x0f, 0x56, 0x41, 0x4f,
	0xfb, 0x85, 0x3b, 0x83, 0x60, 0xff, 0x62, 0xc0, 0xfe, 0x73, 0xcd, 0x7d, 0xfe, 0x0a, 0xbd, 0xd1,
	0x02, 0x7e, 0x0c, 0xdb, 0x34, 0xdf, 0xce, 0x8c, 0x38, 0xab, 0xa4, 0x41, 0x9e, 0xec, 0x8e, 0x52,
	0xc9, 0x53, 0xa8, 0xfb, 0x54, 0xe9, 0xe7, 0x0a, 0xbd, 0x2e, 0x1f, 0x60, 0x7e, 0x36, 0xcb, 0xc9,
	0x2c, 0xcf, 0x19, 0x59, 0x9e, 0xd3, 0x1d, 0x59, 0x9e, 0x3b, 0x93, 0x6f, 0xff, 0xb1, 0x09, 0xfb,
	0x4d, 0xa5, 0x78, 0x5f, 0x74, 0xce, 0x47, 0x5a, 0x16, 0xef, 0x6b, 0xfc, 0xd7, 0xfb, 0x12, 0x0f,
	0xde, 0x4a, 0x5a, 0x8c, 0x2f, 0xdb, 0xf4, 0x7d, 0xc9, 0xa8, 0x9e, 0x90, 0x79, 0x5c, 0x02, 0x7e,
	0x51, 0x5e, 0xe1, 0x2e, 0x82, 0x5a, 0x61, 0x1d, 0xd5, 0x7b, 0xb5, 0x8e, 0x63, 0x68, 0x28, 0x64,
	0x51, 0xc8, 0xf5, 0xf0, 0x2c, 0x94, 0x51, 0xd0, 0xf1, 0x94, 0xb9, 0x71, 0x54, 0x4d, 0xac, 0xb8,
	0x18, 0x27, 0x5f, 0x02, 0x09, 0x33, 0xaa, 0xc7, 0xb7, 0x40, 0x65, 0x6e, 0xa6, 0x03, 0xbb, 0x4c,
	0xf4, 0x92, 0x2a, 0xf2, 0x1d, 0x1c, 0x44, 0xb3, 0x83, 0x84, 0xca, 0xdc, 0x4a, 0xa1, 0x4e, 0x56,
	0x5d, 0xb5, 0x30, 0x81, 0xee, 0x3c, 0x52, 0xe9, 0x5a, 0x6f, 0xbf, 0xa9, 0xb5, 0x4e, 0x4c, 0x94,
	0xfa, 0xbe, 0xbc, 0xb9, 0x98, 0x66, 0xa8, 0x75, 0x4d, 0x45, 0x1f, 0x53, 0x0b, 0xae, 0xb9, 0x0b,
	0xdf, 0xdb, 0x7f, 0x56, 0xa0, 0x31, 0x19, 0xdc, 0xdc, 0x09, 0xde, 0xfc, 0xe4, 0x7e, 0x0d, 0xfb,
	0x91, 0xa2, 0x3d, 0x1f, 0x27, 0xec, 0x56, 0x52, 0x76, 0x3f, 0x5c, 0xc9, 0xee, 0x74, 0x99, 0x5b,
	0x44, 0x49, 0x98, 0x2d, 0x8e, 0x53, 0x3e, 0xa2, 0xaf, 0xef, 0x59, 0x73, 0x48, 0xaf, 0x33, 0x8e,
	0xf6, 0xef, 0x06, 0xec, 0xcd, 0x1c, 0x76, 0x4d, 0x2b, 0xfa, 0x04, 0x6a, 0x21, 0x2a, 0xe9, 0xc7,
	0x18, 0x8e, 0x6d, 0x68, 0x71, 0xd9, 0x38, 0x37, 0xe9, 0xd6, 0xa7, 0x1a, 0x6f, 0xe8, 0x30, 0x27,
	0x60, 0x69, 0xb7, 0x3c, 0xd5, 0xfe, 0x69, 0x03, 0x76, 0xce, 0x5a, 0xf7, 0x67, 0x59, 0xcb, 0xcd,
	0xa4, 0x72, 0xaf, 0x66, 0xc2, 0xe0, 0x30, 0x12, 0x34, 0x33, 0xb6, 0xe9, 0xbd, 0xae, 0xae, 0xb7,
	0xd7, 0xa5, 0x60, 0xe4, 0x12, 0x88, 0x90, 0x22, 0xe6, 0xb3, 0xc3, 0xbd, 0xb1, 0x5e, 0x8b, 0x12,
	0xa8, 0xa4, 0x41, 0xc9, 0x1d, 0x36, 0xd7, 0x6c, 0x30, 0x0f, 0x65, 0xff, 0x6d, 0x00, 0x24, 0x23,
	0x70, 0x6f, 0xcb, 0xff, 0x05, 0xec, 0xe5, 0xc3, 0xdd, 0x95, 0xcf, 0xa2, 0x41, 0x90, 0xaf, 0xfe,
	0xb2, 0xf9, 0x9c, 0x2d, 0x20, 0x6d, 0xd8, 0x1f, 0x07, 0xda, 0xe8, 0xa3, 0xc6, 0x5c, 0xc4, 0x65,
	0x18, 0xc5, 0x92, 0xd3, 0x7f, 0x2a, 0x70, 0xd8, 0x4d, 0x52, 0x9a, 0x7d, 0x14, 0xfa, 0xc5, 0x79,
	0xeb, 0x02, 0xc3, 0xe4, 0x67, 0x03, 0xf9, 0xd5, 0x80, 0x83, 0xb9, 0xef, 0x22, 0xf2, 0xe9, 0xaa,
	0x2b, 0x2f, 0xfa, 0x8a, 0xb3, 0x3e, 0x5b, 0xa3, 0x32, 0x67, 0x7f, 0x00, 0xb5, 0x91, 0x1d, 0x93,
	0x95, 0xea, 0x16, 0xbe, 0x38, 0xac, 0xc7, 0x77, 0x2f, 0xc8, 0xdb, 0x7d, 0x03, 0x95, 0xb3, 0x16,
	0x79, 0x7f, 0x55, 0xdd, 0xd8, 0x21, 0xac, 0xe3, 0xbb, 0xa4, 0x66, 0xe0, 0xcf, 0x6a, 0x2f, 0xb7,
	0xe2, 0x80, 0xd1, 0x80, 0xf7, 0xb6, 0xd2, 0x0f, 0xa8, 0x8f, 0xfe, 0x0d, 0x00, 0x00, 0xff, 0xff,
	0x1e, 0xb6, 0x5f, 0xfb, 0x6e, 0x0e, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TitusAgentVPCServiceClient is the client API for TitusAgentVPCService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TitusAgentVPCServiceClient interface {
	// This ProvisionInstance function has to be called at startup of the instance, and it is idempotent.
	ProvisionInstance(ctx context.Context, in *ProvisionInstanceRequest, opts ...grpc.CallOption) (*ProvisionInstanceResponse, error)
	AssignIP(ctx context.Context, in *AssignIPRequest, opts ...grpc.CallOption) (*AssignIPResponse, error)
	// GC extra IPs
	GC(ctx context.Context, in *GCRequest, opts ...grpc.CallOption) (*GCResponse, error)
}

type titusAgentVPCServiceClient struct {
	cc *grpc.ClientConn
}

func NewTitusAgentVPCServiceClient(cc *grpc.ClientConn) TitusAgentVPCServiceClient {
	return &titusAgentVPCServiceClient{cc}
}

func (c *titusAgentVPCServiceClient) ProvisionInstance(ctx context.Context, in *ProvisionInstanceRequest, opts ...grpc.CallOption) (*ProvisionInstanceResponse, error) {
	out := new(ProvisionInstanceResponse)
	err := c.cc.Invoke(ctx, "/com.netflix.titus.executor.vpc.TitusAgentVPCService/ProvisionInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *titusAgentVPCServiceClient) AssignIP(ctx context.Context, in *AssignIPRequest, opts ...grpc.CallOption) (*AssignIPResponse, error) {
	out := new(AssignIPResponse)
	err := c.cc.Invoke(ctx, "/com.netflix.titus.executor.vpc.TitusAgentVPCService/AssignIP", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *titusAgentVPCServiceClient) GC(ctx context.Context, in *GCRequest, opts ...grpc.CallOption) (*GCResponse, error) {
	out := new(GCResponse)
	err := c.cc.Invoke(ctx, "/com.netflix.titus.executor.vpc.TitusAgentVPCService/GC", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TitusAgentVPCServiceServer is the server API for TitusAgentVPCService service.
type TitusAgentVPCServiceServer interface {
	// This ProvisionInstance function has to be called at startup of the instance, and it is idempotent.
	ProvisionInstance(context.Context, *ProvisionInstanceRequest) (*ProvisionInstanceResponse, error)
	AssignIP(context.Context, *AssignIPRequest) (*AssignIPResponse, error)
	// GC extra IPs
	GC(context.Context, *GCRequest) (*GCResponse, error)
}

func RegisterTitusAgentVPCServiceServer(s *grpc.Server, srv TitusAgentVPCServiceServer) {
	s.RegisterService(&_TitusAgentVPCService_serviceDesc, srv)
}

func _TitusAgentVPCService_ProvisionInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProvisionInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TitusAgentVPCServiceServer).ProvisionInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/com.netflix.titus.executor.vpc.TitusAgentVPCService/ProvisionInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TitusAgentVPCServiceServer).ProvisionInstance(ctx, req.(*ProvisionInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TitusAgentVPCService_AssignIP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssignIPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TitusAgentVPCServiceServer).AssignIP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/com.netflix.titus.executor.vpc.TitusAgentVPCService/AssignIP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TitusAgentVPCServiceServer).AssignIP(ctx, req.(*AssignIPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TitusAgentVPCService_GC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GCRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TitusAgentVPCServiceServer).GC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/com.netflix.titus.executor.vpc.TitusAgentVPCService/GC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TitusAgentVPCServiceServer).GC(ctx, req.(*GCRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TitusAgentVPCService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "com.netflix.titus.executor.vpc.TitusAgentVPCService",
	HandlerType: (*TitusAgentVPCServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ProvisionInstance",
			Handler:    _TitusAgentVPCService_ProvisionInstance_Handler,
		},
		{
			MethodName: "AssignIP",
			Handler:    _TitusAgentVPCService_AssignIP_Handler,
		},
		{
			MethodName: "GC",
			Handler:    _TitusAgentVPCService_GC_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vpc.proto",
}
