package docker

import (
	"fmt"
	"io"
	"regexp"
	"strings"
	"text/template"

	"github.com/docker/docker/api/types"
	"github.com/sirupsen/logrus"
	"gopkg.in/alessio/shellescape.v1"
)

const envFileTemplateStr = `# This file was autogenerated by the titus executor

{{ range $key, $val := .ContainerEnv -}}
export {{ $key }}={{ $val | escape_sq }}
{{ end -}}

{{ if .ImageEnv }}
# These environment variables were in your docker configuration
{{ range $key, $val := .ImageEnv -}}
export {{ $key }}={{ escapeSQWithFallback $key $val }}
{{ end -}}
{{ end -}}

{{ if .InvalidEnv }}
# Any extra invalid env variables will be commented out here:
{{ range $key, $val := .InvalidEnv -}}
# export {{ $key }}={{ $val | escape_sq }}
{{ end -}}
{{ end -}}
`

var (
	funcMap         = template.FuncMap{"escape_sq": shellescape.Quote, "escapeSQWithFallback": escapeSQWithFallback}
	envFileTemplate = template.Must(template.New("").Funcs(funcMap).Parse(envFileTemplateStr))
)

// See here: https://wiki.bash-hackers.org/syntax/pe#use_a_default_value
// This only works under bash AFAIK.
func escapeSQWithFallback(key, fallBackValue string) string {
	// Key does not need to be escaped, because it's always safe
	return fmt.Sprintf("${%s-%s}", key, shellescape.Quote(fallBackValue))
}

type envFileTemplateData struct {
	ContainerEnv map[string]string
	ImageEnv     map[string]string
	InvalidEnv   map[string]string
}

func executeEnvFileTemplate(env map[string]string, imageInfo *types.ImageInspect, buf io.Writer) error {
	imageEnv := make(map[string]string, len(imageInfo.Config.Env))
	invalidEnv := make(map[string]string)

	for _, environmentVariable := range imageInfo.Config.Env {
		splitEnvironmentVariable := strings.SplitN(environmentVariable, "=", 2)
		if len(splitEnvironmentVariable) != 2 {
			logrus.WithField("environmentVariable", environmentVariable).Warning("Cannot parse environment variable")
			continue
		}
		if isValidEnvVariable(splitEnvironmentVariable[0]) {
			imageEnv[splitEnvironmentVariable[0]] = splitEnvironmentVariable[1]
		} else {
			invalidEnv[splitEnvironmentVariable[0]] = splitEnvironmentVariable[1]
		}
	}

	validEnv := make(map[string]string)
	for k, v := range env {
		if isValidEnvVariable(k) {
			validEnv[k] = v
		} else {
			invalidEnv[k] = v
		}
	}

	templateData := envFileTemplateData{ContainerEnv: validEnv, ImageEnv: imageEnv, InvalidEnv: invalidEnv}
	return envFileTemplate.Execute(buf, templateData)
}

func isValidEnvVariable(in string) bool {
	m, _ := regexp.MatchString(`^[a-zA-Z_]+[a-zA-Z0-9_]*$`, in)
	return m
}
